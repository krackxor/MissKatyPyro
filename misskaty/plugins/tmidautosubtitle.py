# * @author        TelMovid
# * @date          2025-08-25 10:33:00
# * @projectName   TelMovid
# * Copyright Â©TelMovID All rights reserved
import os
import speech_recognition as sr
import moviepy.editor as mp
from datetime import timedelta
from pyrogram import filters
from easygoogletranslate import EasyGoogleTranslate
from misskaty import app
from misskaty.vars import COMMAND_HANDLER

__MODULE__ = "autosubtitle"
__HELP__ = """
Command: <code>/autosub [language_code]</code> [reply to video/audio]
Desc: Automatically generate SRT subtitles from video or audio files with optional language translation.
Example: <code>/autosub id</code> for Indonesian, <code>/autosub en</code> for English.
Supported languages: Any valid Google Translate language code (e.g., id, en, es, fr, etc.).
"""

def create_srt(transcription, duration, chunk_length=5):
    srt_content = ""
    for i, text in enumerate(transcription):
        start_time = i * chunk_length
        end_time = min((i + 1) * chunk_length, duration)
        start = str(timedelta(seconds=start_time)).replace(".", ",")
        end = str(timedelta(seconds=end_time)).replace(".", ",")
        srt_content += f"{i+1}\n{start} --> {end}\n{text}\n\n"
    return srt_content

@app.on_message(filters.command(["autosub"], COMMAND_HANDLER))
async def generate_subtitle(client, message):
    # Check if the message is a reply to a video or audio file
    if not message.reply_to_message or not (message.reply_to_message.video or message.reply_to_message.audio):
        return await message.reply("Please reply to a video or audio file to generate subtitles.")

    # Get language code from command (default to 'en' if not specified)
    lang_code = message.command[1] if len(message.command) > 1 else "en"
    
    nan = await message.reply("Processing subtitle generation...")
    try:
        # Download the media file
        media = message.reply_to_message.video or message.reply_to_message.audio
        file_path = await client.download_media(media, file_name=f"temp_{message.from_user.id}")
        
        # Extract audio from video/audio
        audio_file = f"temp_audio_{message.from_user.id}.wav"
        if media.mime_type.startswith("video"):
            video = mp.VideoFileClip(file_path)
            duration = video.duration
            video.audio.write_audiofile(audio_file)
            video.close()
        else:
            audio = mp.AudioFileClip(file_path)
            duration = audio.duration
            audio.write_audiofile(audio_file)
            audio.close()

        # Initialize speech recognizer and translator
        recognizer = sr.Recognizer()
        translator = EasyGoogleTranslate(target_language=lang_code)
        chunk_length = 5  # Process in 5-second chunks
        transcription = []

        # Process audio in chunks
        with sr.AudioFile(audio_file) as source:
            while True:
                try:
                    audio_data = recognizer.record(source, duration=chunk_length)
                    text = recognizer.recognize_google(audio_data)
                    # Translate text to the target language
                    translated_text = translator.translate(text)
                    transcription.append(translated_text if translated_text else "[Translation failed]")
                except sr.UnknownValueError:
                    transcription.append("[Unrecognized speech]")
                except sr.RequestError as e:
                    transcription.append(f"[Error: {e}]")
                except:
                    break

        # Generate SRT file
        srt_content = create_srt(transcription, duration)
        srt_file = f"subtitle_{message.from_user.id}.srt"
        with open(srt_file, "w", encoding="utf-8") as f:
            f.write(srt_content)

        # Send SRT file
        await message.reply_document(
            document=srt_file,
            caption=f"<b>Subtitles Generated By:</b> {client.me.mention} (Language: {lang_code})"
        )

        # Cleanup
        for file in [file_path, audio_file, srt_file]:
            if os.path.exists(file):
                os.remove(file)
        await nan.delete()

    except Exception as e:
        await nan.delete()
        return await message.reply(f"Error generating subtitles: {str(e)}")
